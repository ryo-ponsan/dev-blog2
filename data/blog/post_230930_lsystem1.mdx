---
title: L-system
date: '2023-09-30'
tags: ['USD', '3D']
draft: false
summary: 'L-system tutorial'
authors: ['gypsyR']
---

# 参考サイト一覧

- [Houdini:L-system 概要と作例 01](http://nomoreretake.net/2016/12/15/houdini_l-system_intro/)
- [Houdini:L-system 作例 02](http://nomoreretake.net/2016/12/16/houdinil_system_sample02/)

# 基礎知識

## L-system（Lindenmayer システム）

L-system は、ハンガリーの植物学者アリストード・リンデンマイヤーによって 1968 年に発表された、生物の成長や形態の進化を数学的にモデル化するための形式文法です。主に植物の成長パターンや構造をモデル化するのに使われていますが、その他の自然のパターンを模倣するのにも適しています。

基本的に L-system は、文字列の再帰的な置換に基づいています。初期文字列（アキシオム）と、その文字列の一部を置換するためのルールセットを持っています。再帰的にルールを適用することで、複雑なパターンや構造を生成することができます。

### 基本的な L-system の例

アキシオム: \( A \)
ルール: \( A \rightarrow AB \), \( B \rightarrow A \)

このルールを使うと、以下のように進化します。

1. \( A \)
2. \( AB \)
3. \( ABA \)
4. \( ABAAB \)
   ... と続きます。

## 実現のロードマップ

1. **L-system の基礎理解**: L-system の基本的な概念、アキシオム、生成ルールを理解します。
2. **2D 図形の描画**: 2D 平面上で L-system を利用して図形を描画する方法を学びます。例えば、龍曲線やコッホ曲線などのフラクタル図形を描く方法を学びます。
3. **3D モデリングへの適用**: 3D 空間における L-system の応用を学びます。ここで、植物の枝や葉などの 3D モデルを生成する方法を学びます。
4. **ランダム性の導入**: 一つのルールだけでなく、複数のルールを持ち、それをランダムに選択することで多様性を持ったモデルを生成する方法を学びます。
5. **リアルタイムの成長のシミュレーション**: 植物が成長するプロセスをリアルタイムでシミュレートする方法を学びます。
6. **最適化と高度な技術**: 大量の植物モデルを効率的に生成・レンダリングするための技術やツールを学びます。

## 実現可能性

L-system を用いて植物の 3D モデルを生成することは十分に実現可能です。多くのグラフィックスソフトウェアやゲームエンジンで L-system を利用して植物や自然の景観を生成するプラグインやツールが存在します。自由自在に様々なルールを設定して植物を大量に生成することも、適切な知識と技術を持てば実現できます。

# サンプル

```python
# 簡単なL-systemの実装

def l_system(axiom, rules, iterations):
    """
    L-systemのシミュレーションを行う関数。

    :param axiom: 初期文字列（アキシオム）
    :param rules: 置換ルールの辞書。キーが置換される文字、値が置換後の文字列。
    :param iterations: ルールの適用回数。
    :return: 最終的な文字列。
    """
    result = axiom
    for _ in range(iterations):
        next_result = ""
        for char in result:
            next_result += rules.get(char, char)  # 辞書にキーが存在しなければ、元の文字をそのまま使う
        result = next_result
    return result

# 上記の例で述べたL-system
axiom = "A"
rules = {
    "A": "AB",
    "B": "A"
}

# 4回のイテレーションでの結果
l_system(axiom, rules, 4)


```

### 1. 関数の定義

まず、`l_system`という名前の関数を定義しています。この関数は、3 つの引数を受け取ります。

- `axiom`: アキシオム（初期文字列）です。
- `rules`: 文字の置換ルールを定義する辞書です。
- `iterations`: ルールを適用する回数です。

### 2. 初期状態の設定

関数の中で、`result`という変数に`axiom`の値を代入しています。この`result`は、各イテレーションの結果を格納する変数として機能します。

### 3. ルールの適用

`for _ in range(iterations):`というループを使用して、指定された回数だけルールを適用します。ループ内の処理は以下のようになります。

- `next_result`という新しい空の文字列を初期化します。
- `result`の中の各文字に対してループを実行します。
  - `rules.get(char, char)`というコードで、現在の文字`char`に対応する置換ルールを取得します。もしルールが存在しなければ、`char`をそのまま返します。
  - `next_result`に置換後の文字列を追加します。
- イテレーションが終了すると、`result`に`next_result`の値を代入して、次のイテレーションの準備をします。

### 4. 結果の返却

全てのイテレーションが終了した後、`result`の値（最終的な文字列）を返します。

### 5. 使用例

関数の定義の後、実際に L-system をシミュレートするための例を示しています。アキシオムとして"A"、ルールとして"A"を"AB"に、"B"を"A"に置換するルールを設定し、4 回のイテレーションを実行しています。

関数の動作を理解するために、この例を手作業で追ってみると、以下のような結果になります。

1. `A`
2. `AB`
3. `ABA`
4. `ABAAB`
5. `ABAABABA`

最終的に、`ABAABABA`という文字列が得られます。

このように、`l_system`関数は指定されたアキシオムとルール、イテレーション回数に基づいて L-system のシミュレーションを行い、最終的な文字列を返します。
